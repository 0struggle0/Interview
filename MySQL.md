#### 说一说数据库设计三大范式？

为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。

**第一范式(确保每列保持原子性)**

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

**第二范式(确保表中的每列都和主键相关)**

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键

**第三范式(确保每列都和主键列直接相关,而不是间接相关)**

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。

https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html



#### MySQL常用的存储引擎？

MySQL常用有两种存储引擎：

MyISAM，不支持事务处理，读性能处理快，表级别锁，不支持外键。

InnoDB，支持事务处理，设计目标是为处理大容量数据发挥最大化性能，行级别锁，支持外键。

表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。

行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。



#### MySQL索引类型

- 普通索引

  是最基本的索引，它没有任何限制。

  （1）直接创建索引

  ```sql
  CREATE INDEX index_name ON table(column(length))
  ```

  (2）修改表结构的方式添加索引

  ```sql
  ALTER TABLE table_name ADD INDEX index_name ON (column(length))
  ```

  (3）创建表的时候同时创建索引

  ```sql
  CREATE TABLE `table` (
      `id` int(11) NOT NULL AUTO_INCREMENT ,
      `title` char(255) CHARACTER NOT NULL ,
      `content` text CHARACTER NULL ,
      `time` int(10) NULL DEFAULT NULL ,
      PRIMARY KEY (`id`),
      INDEX index_name (title(length))
  )
  ```

  （4）删除索引

  ```sql
  DROP INDEX index_name ON table
  ```

- 唯一索引

  与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

  （1）创建唯一索引

  ```sql
  CREATE UNIQUE INDEX indexName ON table(column(length))
  ```

  （2）修改表结构

  ```sql
  ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))
  ```

  （3）创建表的时候直接指定

  ```sql
  CREATE TABLE `table` (
      `id` int(11) NOT NULL AUTO_INCREMENT ,
      `title` char(255) CHARACTER NOT NULL ,
      `content` text CHARACTER NULL ,
      `time` int(10) NULL DEFAULT NULL ,
      UNIQUE indexName (title(length))
  );
  ```

- 主键索引

  是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。

  ```sql
  CREATE TABLE `table` (
      `id` int(11) NOT NULL AUTO_INCREMENT ,
      `title` char(255) NOT NULL ,
      PRIMARY KEY (`id`)
  );
  ```

- 组合索引

  指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

  ```SQL
  ALTER TABLE `table` ADD INDEX name_city_age (name,city,age); 
  ```

- 全文索引

  主要用来查找文本中的关键字，而不是直接与索引中的值相比较。

  fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。



#### 说一下什么是组合索引，及使用情况？

由多个字段组成的索引叫组合索引

1、需要加索引的字段，要在where条件中

2、数据量少的字段不需要加索引

3、如果where条件中是 OR 关系，加索引不起作用

4、符合最左原则

Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。

例子：当前组合索引是这样一个顺序 ind_status_email(status,email)
单独查询status时，可以用到这个索引，单独查询email时，却用不到



#### 索引底层是什么数据结构？

Btree



#### 优化Mysql数据库的8个方法

本文通过8个方法优化Mysql数据库：创建索引、复合索引、索引不会包含有NULL值的列、使用短索引、排序的索引问题、like语句操作、不要在列上进行运算、不使用NOT IN和<>操作

**1、创建索引**
对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。
**2、复合索引**
比如有一条语句是这样的：select * from users where area='beijing' and age=22;
如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
**3、索引不会包含有NULL值的列**
只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
**4、使用短索引**
对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
**5、排序的索引问题**
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
**6、like语句操作**
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
**7、不要在列上进行运算**
select * from users where YEAR(adddate)<2007;
将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成
select * from users where adddate<‘2007-01-01';
**8、不使用NOT IN和<>操作**
NOT IN和<>操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替。



#### mysql 优化的一般步骤都有哪些？

1. SQL 优化
开启慢查询日志 ，explain分析 SQL 语句,  分析是否需要加上索引
  
2. 数据库设计优化

   字段类型，范式与逆范式，存储引擎

3. 架构优化

   主从复制，读写分离，分库分表，增加缓存

4. 服务器硬件优化、MySQL配置优化

   提升服务器硬件配置；提高最大连接数；提高能暂存的连接数量；指定缓冲区大小；



#### 说一下怎么优化的查询语句？

1. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段

2. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描

3. 要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

4. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。所以，最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库。

   不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。

5. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描

6. in 和 not in 也要慎用，否则会导致全表扫描；

   对于连续的数值，能用 between 就不要用 in；

   很多时候用 exists 代替 in 是一个好的选择；

7. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

8. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

9. 最好是在相同类型的字段间进行比较的操作，否则这个过程中会有类型转换，造成性能消耗

10. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理



#### 对 mysql 事务的理解？

事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。
1. 事务使用 INNODB 数据库引擎  
如果你不是INNODB ,开启事务,删除那就真的删除了.
2. 要么成批的sql全部执行,要么不执行
3. 事务用来管理   insert  update  delete 的语句

**事物的四个特性（ACID）**

​	原子性： 操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
​	一致性： 事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。
​	隔离性 ：离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
​	持久性： 当事务正确完成后，它对于数据的改变是永久性的。
关键字:

Commit 提交 当一个事务完成后,发出commit 命令使所有的参与表 完成更改.
Rollback 回滚 如果发送故障,发出rollback命令 使事务返回到 所有表以前的状态.

https://www.cnblogs.com/limuzi1994/p/9684083.html



#### mysql 触发器是什么？

 监视某种事件，并触发某种操作 (商品的添加，订单的删除 等等 连贯操作时候使用)

```sql
###触发四要素
    1. 监视地点 table
    2. 触发时间 (after/ before)
    3. 监视事件 (insert/update/delete)
    4. 触发事件 (insert/update/delete)

1、创建一个名为tg1的触发器，当向t1表中插入数据前，就向a表中插入一条数据
delimiter //     mysql中可以转换结束符
mysql>create trigger tg1 before insert on t1 for each row    #固定写法
->begin
-> insert into a values (4);
->end

```



请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别？

Int 整数 char 定长字符 Varchar 变长字符 Datetime 日期时间型 Text 文本型 Varchar 与char的区别 char是固定长度的字符类型，分配多少空间，就占用多长空间。 Varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。 由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类型低。



MyISAM 和 InnoDB 的基本区别？索引结构如何实现？

MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，而InnoDB类型支持事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢。

创建索引：alert table tablename add index (`字段名`)



增加一个字段性别sex，写出修改语句

Alert table user add sex enum(’0′,’1′);



查询出年龄介于20岁到30岁之间的用户

可对where后面的字段 age 建立索引，也可对语句建立存储过程。



数据库索引有几类，分别是什么？什么时候该用索引？

普通索引、主键索引、唯一索引

并非所有的数据库都以相同的方式使用索引，作为通用规则，只有当经常查询列中的数据时才需要在表上创建索引。



对关系型数据库而言，索引是相当重要的概念，请回答有关索引几个问题:

a) 索引的目的是什么?

1、快速访问数据表中的特定信息，提高检索速度

2、创建唯一性索引，保证数据库表中每一行数据的唯一性

3、加速表和表之间的连接

4、使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间

b) 索引对数据库系统的负面影响是什么?

负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改的时候索引也要动态维护，这样就降低了数据的维护速度。

c) 为数据表建立索引的原则有哪些?

1、在最频繁使用的、用以缩小查询范围的字段上建立索引

2、在平频繁使用的、需要排序的字段上建立索引

d) 什么情况下不宜建立索引?

1、对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引

2、对于一些特殊的数据类型，不宜建立索引，比如文本字段(text)，值范围较少的知道等。

7.   指出以下代码片段中的SQL注入漏洞以及解决方法(magic_quotes_gpc = off)

   ```php
   mysql_query(“select id,title from content where catid=’{_GET[catid]}’ and title like ’%_GET[keywords]%’”, $link);
   ```

   注入漏洞主要存在用户提交的数据上，这里的注入漏洞主要是$_GET[catid]和$_GET[keyword]

   解决注入漏洞：

```php
$_GET[catid]=intval($_GET[catid]);
$sql=”select id,title from content where catid=’{$_GET[catid]}’ and title like ’%$_GET[keywords]%”;
$sql=addslashes($sql);
Mysql_query($sql);
```



SQL注入漏洞产生的原因 ? 如何防止?

SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。

防止SQL注入：

1、开启配置文件中的magic_quotes_gpc和magic_quotes_runtime设置

2、执行sql语句时使用addslashes进行sql语句转换

3、Sql语句书写尽量不要省略小引号和单引号

4、过滤掉sql语句中的一些关键字：update、insert、delete、select、*

5、提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。

6、Php配置文件中设置register_globals为off，关闭全局变量注册

7、控制错误信息，不要再浏览器上输出错误信息，将错误信息写到日志文件中

 