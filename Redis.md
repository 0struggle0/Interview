#### 什么是Redis?

Redis全称是远程字典服务器，是一个高性能键值对（key-value）的内存数据库，拥有丰富的数据类型，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。可以用作数据库、缓存、消息中间件等。



#### Redis基本数据类型有哪些？

①String 是 Redis 最基本的类型，一个 Key 对应一个 Value。

Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。

应用场景：

​	作为缓存：缓存动态生成的页面、缓存热数据、缓存计算复杂的结果数据等；

​	作为计数器/id分发器：记录网站每日PV；记录阅读量；记录点赞的数量；记录数据库的主键id等

​	限时服务：比如短信、邮箱验证需要的验证码都有一定的时效；

​	分布式锁：处理一些并发争抢资源的业务时

②Hash是一个键值（key-value）的集合。

Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象及数组。

应用场景：缓存对象、购物车等

③List 列表是简单的字符串列表，按照插入顺序排序。

应用场景：比如 关注列表、最新文章及消息、任务队列、双端队列、优先级队列等

④Set 是 String 类型的无序集合。Set 中的元素是没有顺序的，而且是没有重复的。

应用场景：好友列表、共同好友列表、关注列表、黑白名单、标签、抽奖等

⑤Zset 和 Set 一样是 String 类型元素的集合，且关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列。

使用场景：排行榜



#### Redis除了五种基本数据类型还有哪些类型？

bitmap、HyperLogLog、Geo、Pub/Sub等



#### 那你现在的项目中Redis都应用到了场景

现在的项目中我们用到了：

string类型作为 ：计数器；缓存热数据；定时服务；分布式锁；共享session等

hash类型作为：缓存对象、数组结构；做前置索引

list类型作为：消息队列

zset作为：排行榜



#### 使用过 Redis 分布式锁么，它是什么回事？

先用 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间，防止锁忘记了释放。

这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？

这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。



#### 你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？

缓存和数据库数据一致性问题：

分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。

我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。

合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。



#### Redis 为何这么快?

内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销

单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销

数据结构简单，操作节省时间



#### Redis 和 Memcached 的区别?

redis提供数据持久化功能，memcached无持久化；

redis的数据结构比memcached要丰富，能完成场景以外的事情；

memcached的单个key限制在250B，value限制在1MB；redis的K、V都为512MB;当然这些值可以在源码中修改；

memcached数据回收基于LRU算法，Redis提供了多种回收策略（包含LRU），但是redis的回收策的过期逻辑不可依赖，没法根据是否存在一个key判断是否过期。但是可根据ttl返回值判断是否过期；

memcached使用多线程，而redis使用单线程，基于IO多路复用实现高速访问。所以可以理解为在极端情况下memcached的吞吐大于redis。



#### Redis 雪崩了解吗？



#### Redis缓存穿透和击穿了解吗，可以说说他们跟雪崩的区别吗？



#### Redis 的淘汰策略有哪些？

Redis 有六种淘汰策略



#### Redis 的持久化机制了解吗？

Redis 的持久化策略有两种：

RDB：是用快照形式直接把内存中的数据保存到一个 dump 的文件中，是定时保存策略。

AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。

Redis 默认是快照 RDB 的持久化方式。

当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。



####  RDB 是怎么工作的？

Redis 默认会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。

工作原理：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到一个临时 RDB 文件中。

当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以边写边复制。

RDB 的优点是：

这种文件非常适合用于备份，比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。

RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。



#### AOF是怎么工作的？

使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：

appendfsync yes 

appendfsync always #每次有数据修改发生时都会写入AOF文件

appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。

AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。

AOF 的优点：

可以让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。

缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。

**如果 aof 文件过大恢复时间过长怎么办？**

Redis 会定期做 AOF 重写，压缩 AOF文件日志大小。

Redis 有混合持久化的功能，将 RDB 和 AOF 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。



#### 那应该选择哪一个持久化策略使用？

如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。

AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。

数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。

当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。



#### Redis集群

Redis有三种集群模式，分别是：

主从模式

哨兵模式

Cluster 模式 =》相当于 主从模式 + 哨兵模式

Redis Sentinal  哨兵 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。

Redis Cluster  Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。



#### 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？

这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。



#### 使用过 Redis 做异步队列么，你是怎么用的？

一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。

当 lpop 没有消息的时候，要适当 sleep 一会再重试。

**如果对方追问可不可以不用 sleep 呢？**

list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。

**如果对方追问能不能生产一次消费多次呢？**

使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。

**如果对方追问 pub/sub 有什么缺点？**

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。

**如果对方追问 redis 如何实现延时队列？**

使用 zset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。



#### 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，可能会造成缓存雪崩。

一般需要在时间上加一个随机值，使得过期时间分散一些。



#### Redis 的 Pipeline有什么好处，为什么要用 pipeline？ # pipeline(管道)

可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。

使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。